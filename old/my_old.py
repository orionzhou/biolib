class SeqReconstruct():	def __init__(self, cutOff, lstAcc):		self.cutOff = cutOff;		self.lstAcc = lstAcc;		self.filePos1 = 0;		self.filePos2 = 0;		self.fOut2 = open(os.path.join(DIR_output, "out.fasta.txt"), "w");	def do(self, chr, posStart, posStop, new):		myret = SeqRet();		refSeqRecd = myret.ret(chr, posStart, posStop);		refSeqString = str(refSeqRecd.seq);	   		fPathIn1 = os.path.join(DIR_input, 'variants/MtChr%d_snp.txt' % chr);		fPathIn2 = os.path.join(DIR_input, 'variants/MtChr%d_indel.txt' % chr);		variantRet = VariantRet(fPathIn1);		snpRet = variantRet.ret(chr, posStart, posStop, new, self.filePos1);		self.filePos1 = variantRet.filePosition;		variantRet = VariantRet(fPathIn2);		indelRet = variantRet.ret(chr, posStart, posStop, new, self.filePos2);		self.filePos2 = variantRet.filePosition;		snpRet.update(indelRet);		vtRet = sorted(snpRet.items());		seqRecdLst = [refSeqRecd];		seqIdPrefix = "_".join(["Chr"+str(chr), str(posStart), str(posStop)]);		self.fOut2.write(seqIdPrefix + "\n");		for acc in self.lstAcc:			#lstPos = [posStart];			#lstStr = [refSeqRecd.seq.tostring()];			posPrev = 0;			accSeqString = "";			countTotalV = 0;			countSnp, countIndel = 0, 0;			countMatchedR, countBelowT, countNoC = 0, 0, 0;			for index, row in vtRet:				if row == None:					break;				vtPosGlobal = index;				vtPosLocal = vtPosGlobal - posStart + 1;				countTotalV += 1;				tmp = re.match(".*%s\(\[([.0-9]+)\]" % acc, row["MatchedVariant"]);				if tmp != None:					freq = tmp.group(1);					accSeqString += refSeqString[posPrev: vtPosLocal-1];					if row["Class"]=="S":						accSeqString += row["VarAllele"];						countSnp += 1;					elif row["Class"]=="I":						accSeqString += refSeqString[vtPosLocal-1] + row["VarAllele"];						countIndel += 1;					elif row["Class"] == "D":						arytmp = re.findall("\D*(\d+)\D*", row["Position"]);						vtPosLocal = int(arytmp[1]) - posStart;						countIndel += 1;					else:						print "Unkown variant class: %s in \"%s\"" % (row["Class"], row);						my.sys.exit(1);					posPrev = vtPosLocal;					#for pos,seqstr in zip(lstPos, lstStr):						#pass;				tmp = re.match(".*%s\(\[([.0-9]+)\]" % acc, row["MatchedReference"]);				if tmp != None:					countMatchedR += 1;				tmp = re.match(".*%s.*" % acc, row["BelowThreshold"]);				if tmp != None:					countBelowT += 1;				tmp = re.match(".*%s.*" % acc, row["NoCoverage"]);				if tmp != None:					countNoC += 1;			accSeqString += refSeqString[posPrev:];			accSeqRecd = SeqRecord(Seq(accSeqString));			accSeqRecd.id = seqIdPrefix + "_" + acc;			accSeqRecd.description = "Length=%d;MatchedVariant:(snp=%d,indel=%d);MatchedReference:%d;BelowThreshold:%d;NoCoverage:%d;TotalVariantsInRegion:%d" \				% (len(accSeqString), countSnp, countIndel, countMatchedR, countBelowT, countNoC, countTotalV);			self.fOut2.write("\t" + acc + accSeqRecd.description + "\n");			seqRecdLst += [accSeqRecd];		return seqRecdLst;class ReadsCheck():	"""#check segments of sequences with mt3.0, provides methods in length and sequence	myCheck = ReadsCheck();	myCheck.open('ReferencesSequences.fasta');	#myCheck.lenCheck();	myCheck.seqCheck();	myCheck.close();	"""	def __init__(self):		pass;	def open(self, fName):		fPathIn = os.path.join(DIR_input, fName);		self.fIn = open(fPathIn);		self.seqIterator = SeqIO.parse(self.fIn, "fasta");	def lenCheck(self):		k, j = 0, 0;		for recordIn in  self.seqIterator:			j = j+1;			id_ary = re.split('[\-\_]', recordIn.id);			length1 = abs(int(id_ary[2]) - int(id_ary[1])) + 1;			length2 = len(recordIn);			if length1 != len(recordIn):				print "\t".join([recordIn.id, str(length1), str(length2)]);			else:				k = k+1;		print "\n" + str(k) + " / " + str(j) + ": length verified";	def seqCheck(self):		for recordIn in self.seqIterator:			id_ary = re.split('[\-\_]', recordIn.id);			chr = id_ary[0][-1];			seqRet = SeqRet();			myseqRecord = seqRet.ret(chr, int(id_ary[1]), int(id_ary[2]));			print recordIn.id + "\t",;			if str(recordIn.seq) == str(myseqRecord.seq):				print "verified";			elif str(recordIn.seq) == str(myseqRecord.seq.reverse_complement()):				print "verified - RC";			else:				print "(file)" + recordIn[0:10].seq + "... ",;				print "(mt3.0)" + myseqRecord[0:10].seq;	def close(self):		self.fIn.close();		def blast_mtchr_old(blastPath, qryPath, outPath):	blastCmd = "{0}/bin/blastall -p blastn -d {0}/db/MtChr{1} -i {2} -o {3} -e 1e-5 -m 8 -a 6"	fOut = open(outPath, 'w');	cnt = 0;	for seqRcd in my.getQry(qryPath):		hdr = None;		cnt += 1;		print "Processing sequence %4d (%s) %s" % (cnt,seqRcd.id,seqRcd.description);		for chr in range(9):			ntfQry = tempfile.NamedTemporaryFile(mode='w', delete=False);			tmpOut = ntfQry.name + ".tmp";			hdr = seqRcd.id;			seq = seqRcd.seq.tostring();			ntfQry.write(">"+hdr);			ntfQry.write("\n");			ntfQry.write(seq);			ntfQry.close();			#print(blastCmd.format(blastPath, ntfQry.name, tmpOut));			os.system(blastCmd.format(blastPath, chr, ntfQry.name, tmpOut));			with open(tmpOut, 'r') as fTmpOut:				for line in fTmpOut:					fOut.write(line);			#fOut.write(blastCmd.format(blastPath, ntfQry.name, tmpOut) + '\n');			os.remove(ntfQry.name);			os.remove(tmpOut);	fOut.close();		#Batch blast, set option=1 (2) to blast against MT3_all_BACs.fas (MtChr0-8)def blast_batch(seqRcdLstIn, outPath, evalue, batchSize, option=1, optionMask="T"):	blastPath = DIR_blast;	assert blastPath!= None;	fOut = open(outPath, 'w');	seqRcdLstLst = [];	seqRcdLst = [];	cnt = 0;	for seqRcd in seqRcdLstIn:		cnt += 1;		seqRcdLst.append(seqRcd);		if cnt % batchSize == 0:			seqRcdLstLst.append(seqRcdLst);			seqRcdLst = [];	if cnt % batchSize != 0:		seqRcdLstLst.append(seqRcdLst);	i=0;	j=0;	for seqRcdLst in seqRcdLstLst:		i += 1;		print "batch %2d: %03d-%03d" % (i, (i-1)*batchSize+1, i*batchSize);		ntfQry = tempfile.NamedTemporaryFile(mode='w', delete=False);		tmpOut = ntfQry.name + ".tmp";		for seqRcd in seqRcdLst:			j += 1;			print "\tseq %3d: (%s) %s" % (j,seqRcd.id,seqRcd.description);			hdr = seqRcd.id;			seq = seqRcd.seq.tostring();			ntfQry.write(">"+hdr);			ntfQry.write("\n");			ntfQry.write(seq);			ntfQry.write("\n");		ntfQry.close();		blastCmd = "{0}/bin/blastall -p blastn -d {0}/db/{1} -i {2} -o {3} -e {4} -m 8 -a 6 -F '{5}'";		if option == 1:			os.system(blastCmd.format(blastPath, "MT3_all_BACs.fas", \				ntfQry.name, tmpOut, evalue, optionMask));			with open(tmpOut, 'r') as fTmpOut:				for line in fTmpOut:					fOut.write(line);			#fOut.write(blastCmd.format(blastPath, ntfQry.name, tmpOut) + '\n');			os.remove(tmpOut);		else:			for chr in range(1,9):				#print(blastCmd.format(blastPath, ntfQry.name, tmpOut));				os.system(blastCmd.format(blastPath, "MtChr%d"%chr, ntfQry.name, \					tmpOut, evalue, optionMask));				with open(tmpOut, 'r') as fTmpOut:					for line in fTmpOut:						fOut.write(line);				#fOut.write(blastCmd.format(blastPath, ntfQry.name, tmpOut) + '\n');				os.remove(tmpOut);		os.remove(ntfQry.name);	fOut.close();	return outPath;def blastParseXML(fIn, qrySeqRcdLst, fOut, mm_min, mm_max, evalue):	seqHitLst = [];	seqLst = [];	pos = [];	lstLen = [];	seqDescLst = [];	for seqRcd in qrySeqRcdLst:		seqLst.append(seqRcd.id);		seqDescLst.append(seqRcd.description);		lstLen.append(len(seqRcd));	cnt = 0;	with open(fIn, "r") as fInH:		for blastRcd in NCBIXML.parse(fInH):			if blastRcd.alignments:				pos.append(seqLst.index(blastRcd.query.split()[0]));				seqHitLst.append(blastRcd.query.split()[0]);	seqMissLst = set(seqLst) - set(seqHitLst);	#print pos;	fOutH = open(fOut,"w");	with open(fIn, "r") as fInH:		cntA = 0;		cntB_prev = 0;		cntB_curr = pos[cntA];		fOutH.write("\t".join(["#id","#probe","BAC_loc","mismatch","Chr_loc", \				"BAC_phase","BAC_quality","BAC_notes_1","BAC_notes_2","\n"]));		for blastRcd in NCBIXML.parse(fInH):			if cntB_prev < cntB_curr:				for i in range(cntB_prev,cntB_curr):					fOutH.write("%s\t%s\t" % (seqLst[i],seqDescLst[i]));					fOutH.write("no hit\n");					cntB_prev += 1;			qryLen = lstLen[cntB_curr];			assert blastRcd.query == seqLst[cntB_curr];			fOutH.write("%s\t%s\t" % (seqLst[cntB_curr],seqDescLst[cntB_curr]));			cnt_Hit = 0;			for alignment in blastRcd.alignments:				tmp = re.match(".*([A-Z]{2}\d{4,8})[.\W]*(.*)", alignment.title);				if tmp == None:					print "cound not extract acc.no from '%s'" %alignment.title;					sys.exit(1);				acc = tmp.group(1);				for hsp in alignment.hsps:					if hsp.expect < evalue and len(hsp.query)>=(qryLen-mm_max) \							and len(hsp.query)<=(qryLen-mm_min):						cnt_Hit += 1;						if cnt_Hit > 1:							fOutH.write("\n\t\t");						fOutH.write("%s:%d..%d\t" % (acc, hsp.sbjct_start, hsp.sbjct_end));						fOutH.write("%d\t" % (qryLen-len(hsp.query)));						#fOutH.write("%d\t%d\t" % (hsp.query_start, hsp.query_end));						l2g = local2global();						rst = l2g.do(acc, hsp.sbjct_start, hsp.sbjct_end);						if rst != 0:							fOutH.write("chr%d:%d..%d\t" % (rst[0],rst[1],rst[2]));							fOutH.write("%s\t%s\t%s\t" % (phaseBAC[rst[3]["type"]],rst[3]["quality"],rst[3]["desc"]));						else:							fOutH.write("BAC not anchored\t\t\t\t");						fOutH.write("%s" % (tmp.group(2)));						#print hsp;			if cnt_Hit == 0:				fOutH.write("no hit");			fOutH.write("\n");			cntA += 1;			cntB_prev += 1;			if len(pos) >= cntA+1:				cntB_curr = pos[cntA];	fOutH.close();class VariantParser():	"""#parse an NCGR-formart variant file, write result to 3 different .TXT files, readily importable to local db	fPathIn = DIR_input + 'variant_table.10_30.txt';	variantParser = VariantParser();	variantParser.parse(fPathIn);	"""	def __init__(self, delim = '\t'):		self.delim = delim;		self.Number_acc = 3;		self.Len_acc = 7;		self.Coln_id = 1;		self.Coln_info = 0;		self.Len_info = 16; #13		self.Coln_acc = 16; #13		self.Coln_sum = 37; #34		self.Len_sum = 8;	def parse(self, fPathIn, fPathOut1 = "out1.txt", fPathOut2 = "out2.txt", fPathOut3 = "out3.txt"):		fin = open(fPathIn, 'r');		#fout = open("out", 'w');		fout1 = open(fPathOut1, 'a');		fOut2 = open(fPathOut2, 'a');		fout3 = open(fPathOut3, 'a');		k = 0;		ary_acc = [];		for line in fin:			k = k+1;			ary = line.strip().split(self.delim);							ary_out1 = ary[self.Coln_info : self.Coln_info+self.Len_info];			del(ary_out1[self.Coln_id]);			ary_out1[0:0] = [str(ary[self.Coln_id])];			fout1.write( self.delim + self.delim.join(ary_out1) + "\n");					if k == 1:				ary_out2 = ["Variant", "Accession"]  + ary[self.Coln_acc+1 : self.Coln_acc+self.Len_acc];				for i in range(0, self.Number_acc):					ary_acc.append(str(ary[self.Coln_acc+i*self.Len_acc]));				fOut2.write( self.delim + self.delim.join(ary_out2) + "\n");				#print ary_acc;			else:				for i in range(0, self.Number_acc):					ary_out2 = [ary[self.Coln_id], ary_acc[i]] + ary[self.Coln_acc+i*self.Len_acc+1 : self.Coln_acc+(i+1)*self.Len_acc];					fOut2.write( self.delim + self.delim.join(ary_out2) + "\n");									ary_out3 = [ary[self.Coln_id]] + ary[self.Coln_sum : self.Coln_sum+self.Len_sum];			fout3.write( self.delim + self.delim.join(ary_out3) + "\n");			#fout.write(line);			#if k > 10:				#break;		fin.close();		fout1.close();		fOut2.close();		fout3.close();		print str(k) + " records read";class VariantQuery():	"""#fetch variants from a local/remote database, given proper query string	variantQuery = VariantQuery();	variantQuery.open();	queryString = 'SELECT id,Variant,reference,position \		FROM VariantInfo \		WHERE reference='MtChr3' AND position=0 \		LIMIT 10'; 	result = variantQuery.execute(queryString);	for row in result:		if row == None:			break;		print '\t'.join([str(ele) for ele in row]);		print 'Altogether: %d' % len(result);	variantQuery.close();	"""	def __init__(self):		pass;	def execute(self, QueryString):		try:			cursor = conn.cursor(MySQLdb.cursors.DictCursor);			cursor.execute(QueryString);		except MySQLdb.Error, e:			print "MySQLdb-Error %d: %s" % (e.args[0], e.args[1]);			sys.exit(1);		else:			return cursor.fetchall();	def commit(self):		self.conn.commit();	def close(self):		self.conn.close();class  SeqRet_old():	"""#retieve mt3.0 sequence from local files, e.g.:	myret = SeqRet();	print 'Medicago Chromosome 1 from 1,000,000 to 1,000,100';	print myret.ret(1,100000,100100);	"""	def __init__(self):		pass;	def getSeqRcds(self, chr, gStart, gStop):		cursor = conn.cursor(MySQLdb.cursors.DictCursor);		queryString = "SELECT * FROM mt3 WHERE chr=%d AND ( (chr_start<=%d AND chr_stop>=%d) \			OR (chr_start>%d AND chr_stop<%d) \			OR (chr_start<=%d AND chr_stop>=%d) )" \			% (chr, gStart, gStart, gStart, gStop, gStop, gStop);		cursor.execute(queryString);		result = cursor.fetchall();		assert len(result) > 0;		seqRcdLst = [];		for row in result:			gStartP, gStopP = gStart, gStop;			if(row["chr_start"]<=gStart and row["chr_stop"]>=gStart):				#print "Start:" + row["acc"];				if(row["chr_start"]<=gStop and row["chr_stop"]>=gStop):					pass;					#print "Stop:" + row["acc"];				else:					gStopP = row["chr_stop"];			elif(row["chr_start"]<=gStop and row["chr_stop"]>=gStop):				gStartP = row["chr_start"];				#print "Stop" + row["acc"];			else:				#print "middle:" + row["acc"];				gStartP, gStopP = row["chr_start"], row["chr_stop"];			seqRcdLst.append(self.getSeq(gStartP, gStopP, row));		return seqRcdLst;	def getSeq(self, gStart, gStop, row):		bacStart = int(row["bac_start"]);		bacStop = int(row["bac_stop"]);		chrStart = int(row["chr_start"]);		chrStop = int(row["chr_stop"]);		lStart = coordinateConversion(gStart, chrStart, chrStop, bacStart, bacStop, row["orientation"]);		lStop = coordinateConversion(gStop, chrStart, chrStop, bacStart, bacStop, row["orientation"]);		if lStart > lStop:			lStart, lStop = lStop, lStart;		if(row["type"] == "N"):			#print "Gap\t%d - %d (%d - %d)" % (lStart, lStop, gStart, gStop);			gapSeq = Seq("N"*(lStop-lStart+1));			seqRcd = SeqRecord(gapSeq, id="Gap(%d)" % (lStop-lStart+1));		else:			acc = row["acc"][:row["acc"].index(".")];			accSeqRecd = DB.lookup(accession = acc);			if(row["orientation"] == 1):				sid = "%s:%d..%d" % (acc, lStart, lStop);				seqRcd = SeqRecord(accSeqRecd.seq[lStart-1:lStop], id=sid);				#print "%s: %d..%d - (%d..%d)" % (acc,lStart,lStop,row["chr_start"],row["chr_stop"]);			elif(row["orientation"] == -1):				sid = "revcom(%s:%d..%d)" % (acc, lStart, lStop);				tmpSeq = Seq(accSeqRecd.seq[lStart-1:lStop].tostring());				seqRcd = SeqRecord(tmpSeq.reverse_complement(), id=sid);				#print "revcom(%s): %d..%d - (%d..%d)" % (acc,lStart,lStop,row["chr_start"],row["chr_stop"]);			else:				print "Error!";				sys.exit(0);		return seqRcd;	def ret(self, chr, gStart, gStop):		if gStart > gStop:			gStart, gStop = gStop, gStart;		refSeq, seqPathLst = "", [];		for seqRcd in self.getSeqRcds(chr, gStart, gStop):			seqPathLst.append(seqRcd.id);			refSeq += seqRcd.seq.tostring();		if(len(seqPathLst) > 1):			seqPath = "join("+"; ".join(seqPathLst)+")";		else:			seqPath = seqPathLst[0];		return SeqRecord(Seq(refSeq), id="Chr%d:%s..%s" % (chr, gStart, gStop),  description=seqPath);		class  SeqRet_old2():	"""#retieve mt3.0 sequence from local files, e.g:	myret = SeqRet();	print 'Medicago Chromosome 1 from 1,000,000 to 1,000,100';	print myret.ret(1,100000,100100);	"""	def __init__(self, DIR_mt3=os.path.join(DIR_input, "mt3")):		self.DIR = DIR_mt3;	def readSeq(self, chr): 		fChrName = "MtChr" + str(chr);		fPathChr = os.path.join(self.DIR, fChrName);		try:			self.fChr = open(fPathChr, "r");		except IOError:			print 'cannot open file "' + fPathChr + '"';		else:			self.recordChr = SeqIO.read(self.fChr, "fasta");	def ret(self, chr, posStart, posStop, lenFlg=0):		self.readSeq(chr);		if posStart > posStop:			tmp = posStart;			posStart = posStop;			posStop = tmp;		posStartGlobal = posStart-lenFlg-1;		posStopGlobal = posStop+lenFlg;		recordChrSeg = self.recordChr[posStartGlobal: posStopGlobal];		recordChrSeg.id = "_".join(["Chr"+str(chr), str(posStartGlobal+1), str(posStopGlobal), "RefSeq"]);		recordChrSeg.description = "length=" + str(posStopGlobal-posStartGlobal);		self.fChr.close();		return recordChrSeg;		